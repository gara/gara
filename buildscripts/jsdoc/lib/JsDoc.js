/**
 * @name JsDoc Toolkit
 * @overview An automated documentation publishing system for JavaScript.
 * @version 0.5b
 * @revision $Id: JsDoc.js 313 2007-05-09 21:54:13Z micmath $
 * @author Michael Mathews <a href="mailto:micmath@gmail.com">micmath@gmail.com</a>
 * @license <a href="http://en.wikipedia.org/wiki/MIT_License">X11/MIT License</a>
 *          (See the accompanying README file for full details.)
 */

/**
 * Supress debugging messages cluttering up your terminal.
 * This is independant from the -v/--verbose commandline option, which
 * isn't concerned with debugging messages.
 * @type {boolean}
 */
Quiet = true;

/**
 * Suppress <em>all</em> messages, including warnings. Not recommended.
 * @type {boolean}
 */
Silent = false;

// a mock browser console that does nothing, in case you lack a real one that does something
if (typeof console == "undefined" || typeof console.log == "undefined") {
	console = {log: function(msg) {/*ignored*/}};
}

/**
 * @function warn - Print a warning to stdout or a browser alert box.
 * @param {string} msg
 */
if (typeof warn == "undefined") {
	warn = function(msg, e) {
		if (Silent) return;
		if (e) msg = e.fileName+", line "+e.lineNumber+": "+msg;
		if (typeof alert != "undefined") alert("Warning: "+msg); // in a web browser?
		else print("WARN: "+msg);
	}
}

/**
 * @function explain - Print debugging message to stdout or the browser console.
 * @param {string} msg
 */
if (typeof explain == "undefined") {
	explain = function(msg) {
		if (Silent || Quiet) return;
		if (typeof alert != "undefined") console.log(msg); // in a web browser?
		else print(msg);
	}
}

/**
 * @function inform - Print informative message to stdout or the browser console.
 * @param {string} msg
 */
if (typeof inform == "undefined") {
	inform = function(msg) {
		if (Silent || !JsDoc.opt.v) return;
		if (typeof alert != "undefined") console.log(msg); // in a web browser?
		else print(msg);
	}
}

/**
 * The root namespace for this library.
 */
JsDoc = {};

/**
 * A collection of file objects generated by parsing. One of these will be passed into
 * your <code>TemplateName/publish.js</code> functions as the <code>allFiles</code> argument.
 * @private
 */
JsDoc.FileCollection = function() {
	this.files = [];
}

/**
 * Get a file object.
 * @param {string} n The path name of the file, as given when JsDoc.js was invoked. If missing
 * you'll get all of them, or null if there are none.
 * @return {object} A file object with the given path <code>n</code>.
 * @return {object} An object containing all the files, the keys are the file paths.
 * @return {null} If there are no files present (an unlikely possibility).
 */
JsDoc.FileCollection.prototype.getFile = function(n) {
	return (n === undefined)? this.files : this.files[n];
}

function deploy_begin(context) {}

/**
 * Override this in your <code>templateName/publish.js</code> file or in a loaded
 * file. JsDoc will call it for you once for each source file. This is completed for
 * every source file before publish() is ever called.
 * @param {string} source The contents of the source file. 
 * @param {object} context
 */
function deploy_each(source, context) {}

function deploy_finish(context) {}

/**
 * Override this in your <code>templateName/publish.js</code> file. JsDoc will
 * call it for you once at the beginning of the template phase.
 * @param {JsDoc.FileCollection} allFiles
 * @param {object} context
 */
function publish_begin(allFiles, context) {}

/**
 * Override this in your <code>templateName/publish.js</code> file. JsDoc will
 * call it for you once for each source file.
 * @param {JsDoc.File} file
 * @param {object} context
 */
function publish_each(file, context) {}

/**
 * Override this in your <code>templateName/publish.js</code> file. JsDoc will
 * call it for you once at the end of the template phase.
 * @param {JsDoc.FileCollection} allFiles
 * @param {object} context
 */
function publish_finish(allFiles, context) {}

/**
 * Create doclets and format them into output using JsPlate.
 * @param {object} context A generic object used to pass values in and out of templates. This will be
 *                         pre-populated with the commandline options used to invoke JsDoc.js
                           if in rhino-mode.
 * @param {string|array} srcFiles Either a single file path or an array of file paths.
 * @return {object} The same context object passed in. JsPlate can add an 
 *                  <code>output</code> property to this object if in fly-mode.
 */
JsDoc.publish = function(srcFiles, context) {
	if (context === undefined) {
		warn("No context provided.");
		return;
	}
	JsDoc.opt = context;
	
	if (context.t === undefined) {
		warn("No template provided.");
		return;
	}
	context.t += "/";
	
	try {
		eval(ReadFile(context.t+"publish.js"));
	}
	catch(e) {
		warn("Can't evaluate template \""+context.t+"publish.js\".", e);
		return null;
	}
	
	if (typeof srcFiles == "string") srcFiles = [srcFiles];
	
	deploy_begin(JsDoc.opt);
	var allFiles = new JsDoc.FileCollection();
	for (var i = 0; i < srcFiles.length; i++) {
		var srcFile = srcFiles[i];
		inform("Parsing: "+srcFile);
		
		//try {
			allFiles.files.push(JsDoc.parse(srcFile));
			inform("[ok]");
		//}
		//catch(e) {
		//	warn("Can't parse source file \""+srcFile+"\".", e);
		//}
	}
	deploy_finish(JsDoc.opt);
	
	publish_begin(allFiles, context);
	for (var i = 0; i < allFiles.files.length; i++) {
		publish_each(allFiles.files[i], context);
	}
	publish_finish(allFiles, context);
	
	return context;
}

/**
 * Read in the contents of a source file and find doclets.
 * @private
 * @param {string} srcFile The path to a source code file.
 * @return {object} An instance of JsDoc.File, populated with doclets.
 * @throws {error} Can't read the given source file.
 */
JsDoc.parse = function(srcFile) {
	var file = new JsDoc.File(srcFile);
	
	try {
		var fileContent = new String(ReadFile(srcFile));
	}
	catch(e) {
		throw e;
	}
	
	deploy_each({content: fileContent, fileName: srcFile}, JsDoc.opt);
	
	var comment = /\/\*\*([^*][\S\s]*?)\*\/\s*([^\/\n\r]*)/g;
	while((comments = comment.exec(fileContent)) && comments != null) {
		var commentText = JsDoc.Util.clean(comments[1]);
		var codeLine = comments[2];

		var doclet = new JsDoc.Doclet(commentText, codeLine);

		explain("new doclet name is: "+doclet.name);	
		if		(doclet.isa == "overview")		file.addOverview(doclet);
		else if (doclet.isa == "class")			file.addClass(doclet);
		else if (doclet.isa == "interface")		file.addInterface(doclet);
		else if (doclet.isa == "method")		file.addMethod(doclet);
		else if (doclet.isa == "constructor")	file.addConstructor(doclet);
		else if (doclet.isa == "field")			file.addField(doclet);
		else if (doclet.isa == "function")		file.addFunction(doclet);
		else if (doclet.isa == "global")		file.addGlobal(doclet);
		else {
			file.doclets[doclet.name] = doclet;
			warn("Doclet isa unknown in "+srcFile+" with content: "+commentText);
		}
	}
	
	return file;
};

/**
 * Represents a file of source code.
 * @private
 * @param {string} src Path to the source file.
 */
JsDoc.File = function(src) {
	this.src = src;
	this.name = JsDoc.Util.fileName(src);
	this.overview = {};
	this.doclets = {};
	
	this.classes = {};
	this.interfaces = {};
	this.functions = {};
	this.globals = {};
	
	this._scope = null;
};

/**
 * @private
 * @method
 * @param {object} newDoclet
 */
JsDoc.File.prototype.addOverview = function(newDoclet) {
	this.overview = newDoclet;
}

// TODO: is this ever used?
JsDoc.File.prototype.getOverview = function(n) {
	return (n !== undefined)? this.overview[n] :
		(JsDoc.Util.hasProperties(this.overview))? this.overview : null;
}

/**
 * @private
 * @method
 * @param {object} newDoclet
 */
JsDoc.File.prototype.addClass = function(newDoclet) {
	this._scope = newDoclet.name;
	
	this.classes[newDoclet.name] = 
	this.doclets[newDoclet.name] = newDoclet;
}

/**
 * @private
 * @method
 * @param {object} newDoclet
 */
JsDoc.File.prototype.addInterface = function(newDoclet) {
	this._scope = newDoclet.name;
	
	this.interfaces[newDoclet.name] = 
	this.doclets[newDoclet.name] = newDoclet;
}

/**
 * @method
 * @param {string} n The full runtime name of the class constructor. If missing
 * you'll get all of them, or null if there are none.
 * @return {object} A class doclet with the given name <code>n</code>.
 * @return {object} An object containing all the classes.
 * @return {null} If there are no classes present.
 */
JsDoc.File.prototype.getInterface = function(n) {
	return (n !== undefined)? this.interfaces[n] :
		(JsDoc.Util.hasProperties(this.interfaces))? this.interfaces : null;
}

/**
 * @method
 * @param {string} n The full runtime name of the class constructor. If missing
 * you'll get all of them, or null if there are none.
 * @return {object} A class doclet with the given name <code>n</code>.
 * @return {object} An object containing all the classes.
 * @return {null} If there are no classes present.
 */
JsDoc.File.prototype.getClass = function(n) {
	return (n !== undefined)? this.classes[n] :
		(JsDoc.Util.hasProperties(this.classes))? this.classes : null;
}

/**
 * @private
 * @method
 * @param {object} newDoclet
 */
JsDoc.File.prototype.addMethod = function(newDoclet) {
	var parent = JsDoc.Util.findParent(this.interfaces, newDoclet.name);
	if (parent) {
		if(this.interfaces[parent]) {
			this.interfaces[parent].methods[newDoclet.name] =
			this.doclets[newDoclet.name] = newDoclet;
		}
	} else {
		parent = JsDoc.Util.findParent(this.classes, newDoclet.name);
		if (!parent) parent = this._scope;
		if(this.classes[parent]) {
			this.classes[parent].methods[newDoclet.name] =
			this.doclets[newDoclet.name] = newDoclet;
		}
	} 
}

/**
 * @private
 * @method
 * @param {object} newDoclet
 */
JsDoc.File.prototype.addConstructor = function(newDoclet) {
	var parent = JsDoc.Util.findParent(this.classes, newDoclet.name);
	if (!parent) parent = this._scope;
	if(this.classes[parent]) {
		this.classes[parent].ctors[newDoclet.name] =
		this.doclets[newDoclet.name] = newDoclet;
	}
}

// getMethod: from class

/**
 * @private
 * @method
 * @param {object} newDoclet
 */
JsDoc.File.prototype.addField = function(newDoclet) {
	var parent = JsDoc.Util.findParent(this.classes, newDoclet.name);
	if(this.classes[parent]) {
		this.classes[parent].fields[newDoclet.name] =
		this.doclets[newDoclet.name] = newDoclet;
	}
}
// getField: from class

/**
 * @private
 * @method
 * @param {object} newDoclet
 */
JsDoc.File.prototype.addFunction = function(newDoclet) {
	this.functions[newDoclet.name] = 
	this.doclets[newDoclet.name] = newDoclet;
}

/**
 * @method
 * @param {string} n The full runtime name of the function. If missing
 * you'll get all of them, or null if there are none.
 * @return {object} A function doclet with the given name <code>n</code>.
 * @return {object} An object containing all the functions.
 * @return {null} If there are no functions present.
 */
JsDoc.File.prototype.getFunction =	function(n) {
	return (n !== undefined)? this.functions[n] :
		(JsDoc.Util.hasProperties(this.functions))? this.functions : null;
}

/**
 * @private
 * @method
 * @param {object} newDoclet
 */
JsDoc.File.prototype.addGlobal = function(newDoclet) {
	this.globals[newDoclet.name] = 
	this.doclets[newDoclet.name] = newDoclet;
}

/**
 * @method
 * @param {string} n The full runtime name of the global variable. If missing
 * you'll get all of them, or null if there are none.
 * @return {object} A global variable doclet with the given name <code>n</code>.
 * @return {object} An object containing all the global variables.
 * @return {null} If there are no global variable present.
 */
JsDoc.File.prototype.getGlobal = function(n) {
	return (n !== undefined)? this.globals[n] :
		(JsDoc.Util.hasProperties(this.globals))? this.globals : null;
}

/**
 * @method
 * @param {string} n The full runtime name of the doclet. If missing
 * you'll get all of them, or null if there are none.
 * @return {object} A doclet with the given name <code>n</code>.
 * @return {object} An object containing all the doclets.
 * @return {null} If there are no doclets present.
 */
JsDoc.File.prototype.getDoclet = function(n) {
	return (n === undefined)? this.doclets : this.doclets[n];
}

/**
 * @private
 * @static
 * @class Handle any work required to get info from source code.
 */
JsDoc.CodeParser = {
	_scope: null,
	
	/**
	 * @private
	 * @method Set the name of the class the parser is now in.
	 */
	setScope: function(newScope) {
		this._scope = newScope;
	},
	
	/**
	 * @private
	 * @method Return the name of the class the parser thinks it is currently in.
	 */
	getScope: function() {
		return this._scope;
	},
	
	/**
	 * @private
	 * @field {object} Used to identify various code features in a code line.
	 */
	patterns: {
		functionDeclaration: /^function\s+([a-z_$][$_0-9a-z.]*)\s*\(/i,
		variableAssignment:  /^(?:var\s+)?([a-z_$][$_0-9a-z.]*)\s*=/i,
		propertyAssignment:  /^\s*(["']?)([a-z_$][$_0-9a-z.]*)\1\s*:/i,
		thisAssignment:      /^\s*this\.([a-z_$][$_0-9a-z.]*)\s*[:=]/i,
		prototypeAssignment: /(.+)\.prototype\.(.+)\s*=/,
		functionAssignment:  /[:=]\s*function\s*\(/
	},
	
	/**
	 * @private
	 * @method From a line of code, try to find the name of the object being documented.
	 */
	findName: function(codeline) { explain("\n===============================\nfindName(\""+codeline+"\")")
		var result = {tags:"", isa:null, name:null, shortName:"", longName:"", parentName:""};

		if (codeline == null || codeline == "") return result;
				
		if (this.patterns.prototypeAssignment.test(codeline)) { explain("prototypeAssignment?");
			result.shortName = RegExp.$2;
			result.parentName = RegExp.$1;
			result.longName = result.parentName+"."+result.shortName;
			result.tags = "@field "+result.longName; // shared_field
			result.isa = "field";
			
			if (this.patterns.functionAssignment.test(codeline)) {
				result.tags = "@method "+result.longName; // shared_method
				result.isa = "method";
			}
		}
		else if (this.getScope() && this.patterns.thisAssignment.test(codeline)) { explain("thisAssignment?");
			result.shortName = RegExp.$1;
			result.parentName = this.getScope();
			result.longName = result.parentName+"."+result.shortName;
			result.tags = "@field "+result.longName; // instance_field
			result.isa = "field";
			
			if (this.patterns.functionAssignment.test(codeline)) {
				result.tags = "@method "+result.longName; // instance_method
				result.isa = "method";
			}
		}
		else if (this.getScope() && this.patterns.propertyAssignment.test(codeline)) { explain("propertyAssignment?");
			result.shortName = RegExp.$2;
			result.parentName = this.getScope();
			result.longName = result.parentName+"."+result.shortName;
			result.tags = "@field "+result.parentName+"."+result.shortName; // field
			result.isa = "field";

			if (this.patterns.functionAssignment.test(codeline)) {
				result.tags = "@method "+result.longName; // method
				result.isa = "method";
			}
		}
		else if (this.patterns.functionDeclaration.test(codeline)) { explain("functionDeclaration?");
			result.shortName = RegExp.$1;
			result.longName = result.shortName;
			result.tags = "@function "+result.longName;
			result.isa = "function";
			
		}
		else if (this.patterns.variableAssignment.test(codeline)) { explain("variableAssignment?");
			result.shortName = RegExp.$1;
			result.longName = result.shortName;
			result.tags = "@global "+result.longName;
			result.isa = "global";
			
			if (this.patterns.functionAssignment.test(codeline)) {
				result.isa = "function";
				result.tags = "@function "+result.longName;
			}
			this.setScope(result.longName);
		}
		
		if (result.isa == "function") { explain("function isa class? "+result.longName);
			// a class constructor, like Foo() or baz.Foo()
			if (/(^|\.)[A-Z][^.]+$/.test(result.longName)) {
				result.tags = "@class "+result.longName;
				result.isa = "class";
				this.setScope(result.longName);
			}
			// a static method, like baz.Foo.bar()
			else if (/(^|\.)[A-Z]/.test(result.longName) && /(.+)\.([^A-Z].*?)$/.test(result.longName)) {
				result.shortName = RegExp.$2;
				result.parentName = RegExp.$1;
				result.longName = result.parentName+"."+result.shortName;
				result.tags = "@static\n@method "+result.longName;
				result.isa = "method";
			}
			// otherwise it's a function, like foo()
		}
		
		if (result.isa == "global") { explain("global isa class? "+result.longName);
			// a static class, like Foo = {} or baz.Foo = {} but not FOO = {}
			if (/(^|\.)([A-Z][^.]+)$/.test(result.longName)) {
				if (/[a-z]/.test(result.shortName)){
					if (/=\s*\{/.test(codeline)) {
						result.tags = "@static\n@class "+result.longName;
						result.isa = "class";
						this.setScope(result.longName);
					}
				}
			}
			// a static field, like Foo.bar = "huza" or baz.Foo.bar = "huza"
			else if (/(^|\.)[A-Z]/.test(result.longName) && /(.+)\.([^A-Z].*?)$/.test(result.longName)) {
				result.shortName = RegExp.$2;
				result.parentName = RegExp.$1;
				result.longName = result.parentName+"."+result.shortName;
				result.tags = "@static\n@field "+result.longName; //static_property
				result.isa = "field";
			}
		}
		
		// TODO - handle addon methods, like Array.prototype.scramble = function(){};
		
		explain("---------------");
		explain("tags   => "+result.tags)
		explain("isa    => "+result.isa)
		explain("shortName   => "+result.shortName)
		explain("parentName => "+result.parentName)
		explain("longName   => "+result.longName)
		explain("---------------");
		
		return result;
	}
}

/**
 * Various utility methods used by JsDoc.
 */
JsDoc.Util = {
	
	/**
	 * What characters pad the start of lines inside a doc comment?
	 * @private
	 * @type {regexp} 
	 */
	indent: /^\s*\* ?/gm,
	
	/**
	 * Remove leading padding characters.
	 * @private
	 * @param {string} text
	 */
	clean: function(text) {
		return text.replace(JsDoc.Util.indent, "");
	},
	
	/**
	 * Does the given object have any properties?
	 * @private
	 * @param {object} o An object.
	 * @return {boolean}
	 */
	hasProperties: function(o) {
		for (p in o) return true;
		return false;
	},
	
	/**
	 * Turn a path into just the name of the file.
	 * @private
	 * @param {string} path
	 * @return {string} The fileName portion of the path.
	 */
	fileName: function(path) {
		var nameStart = Math.max(path.lastIndexOf("/")+1, path.lastIndexOf("\\")+1, 0);
		return path.substring(nameStart);
	},
	
	/**
	 * Turn a path into just the directory part.
	 * @private
	 * @param {string} path
	 * @return {string} The directory part of the path.
	 */
	dir: function(path) {
		var nameStart = Math.max(path.lastIndexOf("/")+1, path.lastIndexOf("\\")+1, 0);
		return path.substring(0, nameStart-1);
	},
	
	/**
	 * For use in rhino-mode, get recursive list of files in a directory.
	 * @private
	 * @param {array} dirs Paths to directories to search.
	 * @param {int} recurse How many levels to descend, defaults to 1.
	 * @return {array} Paths to found files.
	 */
	ls: function(dirs, recurse, allFiles, path) {
		if (allFiles === undefined) {
			var allFiles = [];
			var path = [];
		}
		if (recurse === undefined) recurse = 1;
		
		for (var d in dirs) {
			if (String(dirs[d]).match(/^\.[^\.\/\\]/)) continue; // skip dot files
			
			file = (path.concat(dirs[d])).join("/");
			file = file.replace("//", "/");
			
			var files = (new File(file)).list();
			if (files) { // it's a directory
				path.push(dirs[d]);
				if (recurse > 0) JsDoc.Util.ls(files, --recurse, allFiles, path);
				path.pop();
			}
			else {
				allFiles.push(file);
			}
		}

		return allFiles;
	},
	
	/**
	 * For use in rhino-mode, get commandline option values.
	 * @private
	 * @param {Array} args - Commandline arguments. Like ["-a=xml", "-b", "--class=new", "--debug"]
	 * @param {object} optNames - Map short names to long names. Like {a:"accept", b:"backtrace", c:"class", d:"debug"}.
	 * @return {object} Short names and values. Like {a:"xml", b:true, c:"new", d:true}
	 */
	getOptions: function(args, optNames) {
		var opt = {"_": []};
		for (var i = 0; i < args.length; i++) {
			var arg = new String(args[i]);
			var name;
			var value;
			if (arg.charAt(0) == "-") {
				if (arg.charAt(1) == "-") { // it's a longname like --foo
					arg = arg.substring(2);
					var m = arg.split("=");
					name = m.shift();
					value = m.shift();
					
					for (var n in optNames) { // convert it to a shortname
						if (name == optNames[n]) {
							name = n;
							if (typeof value == "undefined") value = true;
							continue;
						}
					}
				}
				else { // it's a shortname like -f
					arg = arg.substring(1);
					var m = arg.split("=");
					name = m.shift();
					value = m.shift();;
					
					if (typeof value == "undefined") value = true;
				}
				
				opt[name] = value;
			}
			else { // not associated with any optname
				opt._.push(args[i]);
			}
		}
		return opt;
	},
	
	/**
	 * @private
	 * @method Find longest matching class name, given a child object's name.
	 * @param {object} classes - A hash of candidate parents. Property names are
	 * the names of the parent objects.
	 * @param {string} childName
	 * @return {string} The found parent's name.
	 */
	findParent: function(classes, childName) {
		var parts = childName.split(".prototype.");
		if (parts != null && parts.length == 2) {
			return parts[0];
		}
		
		var nameParts = childName.split(".");
		var parent = "";
		var path = [];
		for (var n in nameParts) {
			path.push(nameParts[n]);	
			if (typeof classes[path.join(".")] != "undefined") {
				parent = path.join(".");
			}
		}
		return parent;
	}
}

/**
 * A unit of documentation. Could represent a class or a method, for example.
 * @private
 * @param {string} commentText The entire text of the doc comment.
 * @param {string} codeLine The first line of source code that follows the doc comment.
 */
JsDoc.Doclet = function(commentText, codeLine) {
	var code = JsDoc.CodeParser.findName(codeLine);
	this.name = code.longName;
	
	this.shortName = code.shortName;
	this.longName = code.longName;
	this.parentName = code.parentName;
		
	this.type = "";
	this.description = "";
	this.codeLine = codeLine;
	this.tags = {};
	
	this.isa = "";
	this.attributes = [];
	
	// shortcuts to commonly used groups of tags, e.g. this.params == doclet.tags['param']
	this.params = [];	// tags
	this.returns = [];	// tags
	this['throws'] = [];// tags
	this.methods = {};	// doclets
	this.fields = {};	// doclets
	this.ctors = [];	// tag
	this.etc = [];		// tags - everything else
	
	/** Has this doclet been marked as private?
	 * @type {boolean}
	 */
	this.isPrivate = false;
	
	/** Has this doclet been marked as (or does it appear to be) static?
	 * @type {boolean}
	 */
	this.isStatic = false;

	this.isAbstract = false;
		
	// if doclet starts with untagged text, then that text is @summary
	if (commentText.match(/^\s*[^@\s]/)) {
		commentText = "@description "+commentText;
	}
	
	commentText = code.tags+"\n"+commentText;
	explain("commentText is:\n"+commentText+"\n\n")

	var tagTexts = commentText.split(/(^|[\r\f\n])\s*@/);
	
	for (var i = 0; i < tagTexts.length; i++) {
		if (!tagTexts[i].match(/^\w/)) continue; // may have empty elements on some platforms

		var tag = new JsDoc.Tag(tagTexts[i]);
		
		if (tag.isa == "docletType") {
			if (tag.name != "") this.name = tag.name;
			
			explain("Setting name from @doclettype tag to \""+this.name+"\"")
			if (tag.type != "") this.type = tag.type;
			if (tag.description != "") this.description = tag.description;
		}
		
		if (tag.title == "name") {
			this.name = tag.name+tag.description;
			explain("Setting name from @name tag to \""+this.name+"\"")
		}
		else if (tag.title == "overview") {
			this.isa = "overview";
		}
		else if(tag.title == "class") {
			this.isa = "class";
			JsDoc.CodeParser.setScope(this.name);
		}
		else if(tag.title == "interface") {
			this.isa = "interface";
			JsDoc.CodeParser.setScope(this.name);
		}
		else if(tag.title == "constructor") {
			this.isa = "constructor";
			if (tag.name != "") this.name = tag.name;
		}
		else if(tag.title == "method") {
			this.isa = "method";
		}
		else if(tag.title == "function") {
			this.isa = "function";
		}
		else if(tag.title == "global") {
			this.isa = "global";
		}
		else if(tag.title == "field") {
			this.isa = "field";
		}
		else {
			if(tag.title == "private") {
				this.isPrivate = true;
				this.attributes.push("private");
			}
			else if(tag.title == "static") {
				this.isStatic = true;
				this.attributes.push("static");
			}
			else if(tag.title == "abstract") {
				this.isAbstract = true;
				this.attributes.push("abstract");
			}
			else if(tag.title == "param") {
				this.params.push(tag);
			}
			else if(tag.title == "return") {
				this.returns.push(tag);
			}
			else if(tag.title == "throws") {
				this['throws'].push(tag);
			}
			else if(tag.title == "description") {
				this.description = tag.description;
			}
			else if(tag.title == "type") {
				this.type = (tag.type)? tag.type : tag.name+tag.description;
			}
			else {
				this.etc.push(tag);
			}
			
			if (this.tags[tag.title] == null) this.tags[tag.title] = [];
			this.tags[tag.title].push(tag);
		}	
	}
}

/**
 * Get a parameter of this doclet.
 * @param {int} [n] The index of the param, if missing you'll get all of them.
 * @return {array|object}
 */
JsDoc.Doclet.prototype.getParam = function(n) {
	return (n !== undefined)? this.params[n] :
		(JsDoc.Util.hasProperties(this.params))? this.params : null
}

/**
 * Get a list of all the names of the params this doclet takes (handy for generating signature).
 * @return {array} The names of all the parameter tags to this doclet.
 */
JsDoc.Doclet.prototype.getParamNames = function() {
	var names = [];
	for (var i in this.params) names.push(this.params[i].name);
	return names;
}

/**
 * Get a return of this doclet.
 * @param {int} [n] The index of the return, if missing you'll get all of them.
 * @return {array|object}
 */
JsDoc.Doclet.prototype.getReturn = function(n) {
	return (n !== undefined)? this.returns[n] : (this.returns.length > 0)? this.returns : null
}

/**
 * Get a list of all the types returned by this doclet (handy for generating signature).
 * @return {array} The types of all the returns.
 */
JsDoc.Doclet.prototype.getReturnTypes = function(n) {
	var types = [];
	for (var i in this.returns) if (this.returns[i].type != "") { types.push(this.returns[i].type); };
	return types;
}

/**
 * Get a throw of this doclet.
 * @param {int} [n] The index of the thow, if missing you'll get all of them.
 * @return {array|object}
 */
JsDoc.Doclet.prototype.getThrow = function(n) {
	return (n !== undefined)? this['throws'][n] : (this['throws'].length > 0)? this['throws'] : null;
}

/**
 * Get the constructor of this class.
 * @param {int} [n] The index of the constructor, if missing you'll get all of them.
 * @return {array|object}
 */
JsDoc.Doclet.prototype.getConstructor = function(n) {
	return (n !== undefined)? this.ctors[n] : 
		(JsDoc.Util.hasProperties(this.ctors))? this.ctors : null;
}

/**
 * Get a method of this class.
 * @param {int} [n] The index of the method, if missing you'll get all of them.
 * @return {array|object}
 */
JsDoc.Doclet.prototype.getMethod = function(n) {
	return (n !== undefined)? this.methods[n] : 
		(JsDoc.Util.hasProperties(this.methods))? this.methods : null;
}

/**
 * Get a field of this class.
 * @param {int} [n] The index of the field, if missing you'll get all of them.
 * @return {array|object}
 */
JsDoc.Doclet.prototype.getField = function(n) {
	return (n !== undefined)? this.fields[n] : 
		(JsDoc.Util.hasProperties(this.fields))? this.fields : null;
}

/**
 * Get the attributes of this doclet. Not very useful as a longer way to get the
 * same information available from the isPrivate or isStatic fields.
 * @param {int} [n] The index of the attribute, if missing you'll get all of them.
 *                Values that appear here will be either "static" or "private."
 * @return {array|object}
 */
JsDoc.Doclet.prototype.getAttributes = function(n) {
	return (n !== undefined)? this.attributes[n] : (this.attributes.length > 0)? this.attributes : null;
}

/**
 * Get the other tags in this doclet.
 * @param {int} [n] The index of the tag, if missing you'll get all of them. This collection is
 * limited to all the user-defined tags, those that have no special meaning to JsDoc.
 * @return {array|object}
 */
JsDoc.Doclet.prototype.getEtc = function(n) {
	return (n !== undefined)? this.etc[n] : (this.etc.length > 0)? this.etc : null;
}

/**
 * Get a tag in this doclet.
 * @param {int} [n] The index of the tag, if missing you'll get all of them.
 * @return {array|object}
 */
JsDoc.Doclet.prototype.getTag = function(n) {
	if (n !== undefined) {
		return this.tags[n];
	}
	else {
		var allTags = [];
		for (var t in this.tags) {
			for (var i in this.tags[t]) {
				allTags.push(this.tags[t][i]);
			}
		}
		return allTags;
	}
}

/**
 * A tagged item of information about a doclet.
 * @private
 * @param {string} text The complete content of a doclet tag.
 */
JsDoc.Tag = function(text) {
	this.type = "";
	this.name = "";
	this.description = "";
	this.isa = "";

	var tagParts = text.match(/(\S+)\s*([\S\s]*\S)?/);
	if (tagParts) {
		this.title = tagParts[1].toLowerCase();
		var body = (tagParts[2]? tagParts[2] : "");
		
		// define tag-title synonyms here
		if (this.title == "returns")		this.title = "return";
		else if (this.title == "argument")		this.title = "param";
		else if (this.title == "file")			this.title = "overview";
		else if (this.title == "fileoverview")	this.title = "overview";
		else if (this.title == "projectdescription") this.title = "overview";
		
		if (
			this.title == "summary"
			|| this.title == "overview"
			|| this.title == "class"
			|| this.title == "interface"
			|| this.title == "method"
			|| this.title == "constructor"
			|| this.title == "field"
			|| this.title == "function"
			|| this.title == "global"
		) {
			this.parseTag(body);
			this.isa = "docletType";
		}
		else if (this.title == "param") {	// name is always required for params
		  this.parseTag(body, true);
		}
		else {
			this.parseTag(body);
		}
	}
}

/**
 * Find the {type} name - description in a tag body.
 * @private
 * @param {string} body
 * @param {boolean} forceName Always use the first word of the description as
 *                            the tag name, even without a dash present.
 */ 
JsDoc.Tag.prototype.parseTag = function(body, forceName) {
	var parts = body.match(/(?:\{\s*(.+?)\s*\})?([\S\s]*\S)?/);
	if (parts) {
		// there's a type
		this.type = (parts[1] != null)? parts[1] : "";
		
		// there's more
		if (parts[2]) {
			var nameDesc = parts[2].match(/^\s*(\S+)?(\s+-)?\s*([\S\s]+)?$/i);
			// is there a first word?
			if (nameDesc[1] && nameDesc[1].match(/^(\[?)([$_a-z][$_a-z0-9.]*(\.[$_a-z][$_a-z0-9.]*)*)\]?$/i)) {
				// is there a dash or the is the name always required?
				if (nameDesc[2] || forceName) {
					// is this a param with a name like [foo]?
					if (RegExp.$1) {
						if (this.title == "param") {
							this.isOptional = true;
						}
						this.name = RegExp.$2;
						this.description = (nameDesc[3])? nameDesc[3] : "";
					}
					else {
						if (this.title == "param") {
							this.isOptional = false;
						}
						this.name = RegExp.$2;
						this.description = (nameDesc[3])? nameDesc[3] : "";
					}
					
					// is the {type} stored in the description (instead of where it should be)?
					if (this.title == "param" && this.type == "") {
						var typeDesc = this.description.match(/^(?:\{\s*(.+?)\s*\})?([\S\s]*\S)?/);
						if (typeDesc[1]) this.type = typeDesc[1];
						if (typeDesc[2]) this.description = typeDesc[2];
					}
					
					explain(this.title+" > "+this.name+((this.optional)? " optional":""));
				}
				// there's no no dash nor description
				else if (!nameDesc[3]) {
					this.name = nameDesc[1];
				}
			}
			
			// whole thing is a description
			if (!this.name) {
				this.description = parts[2];
			}
		}
	}
}

/**
 * This is called automatically when running in rhino-mode.
 * @private
 */
JsDoc.main = function(opt) {
	JsDoc.opt = opt;
	
	if (opt.h || opt._.length == 0 || opt.t == "") {
		JsDoc.usage();
	}
	
	var recurse = 1;                                        // default is to stay in first
	if (opt.r === true) recurse = 10;                       // if -r then go 10 levels down max
	if (!isNaN(parseInt(opt.r))) recurse = parseInt(opt.r); // if -r=n then go n levels down max
	inform("recurse set to "+recurse+".");
	
	var allFiles = JsDoc.Util.ls(opt._, recurse);
	var srcFiles = [];
	
	// filter out non-js files
	for (var f in allFiles) {
		if (allFiles[f].match(/\.js(doc)?$/i)) srcFiles.push(allFiles[f]); 
	}
	
	explain("Ready to process the following files:\n"+srcFiles);
	
	if (!opt.d) opt.d = "js_docs_out";
	MakeDir(opt.d);
	
	//TODO: there must be a better way to find the path to the executing script?
	var thisFile;
	try {fail();}
	catch(e) {thisFile = e.fileName;}
	
	load(JsDoc.Util.dir(thisFile)+"/JsPlate.js");
	
	if (opt.l) {
		inform("loading "+opt.l+".");
		load(opt.l);
	}

	JsDoc.publish(srcFiles, opt);
}

/**
 * Print out the expected usage syntax for this script on the command
 * line. This is called automatically by using the -h/--help option.
 */
JsDoc.usage = function() {
	print("USAGE: java -jar js.jar jsdoc.js [OPTIONS] <SRC_DIR> <SRC_FILE> ...");
	print("");
	print("OPTIONS:");
	print("  -t=<PATH> or --template=<PATH>\n          Required. Use this template to format the output.\n");
	print("  -d=<PATH> or --directory=<PATH>\n          Output to this directory (defaults to js_docs_out).\n");
	print("  -r=<DEPTH> or --recurse=<DEPTH>\n          Descend into src directories.\n");
	print("  -p or --private\n          Show private methods and fields in output (not yet implemented).\n");
	print("  -v or --verbose\n          Provide some feedback about what is happening.\n");
	print("  -l or --load\n          Load a plug-in script.\n");
	print("  -h or --help\n          Show this message and exit.\n");
	
	java.lang.System.exit(0);
}

if (typeof Packages != "undefined") {
	/**
	 * @private
	 * @global {native} Shortcut to Packages.java.io.FileWriter.
	 */
	FileWriter = Packages.java.io.FileWriter;
	
	/**
	 * @private
	 * @global {native} Shortcut to Packages.java.io.File.
	 */
	File = Packages.java.io.File;
	
	/**
	 * @private
	 * @global {string} Shortcut to Packages.java.io.File.separator
	 */
	FileSeparator = Packages.java.io.File.separator;
}

/**
 * @function Polymorphic (either fly or rhino-mode). Gets the contents of a file.
 * @param {path|url} url
 * @throws {error} Unsupported environment.
 * @return {string} The contents of the file at the given location.
 */
ReadFile = function() {
	if (typeof window != "undefined") {
		if (window.ActiveXObject) {  // call ActiveX first in IE7 due to read permissions for local files
			var xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
		}
		else if (window.XMLHttpRequest) {
			var xmlHttp = new XMLHttpRequest;
		}
		else {
			throw new Error("Unsupported environment.");
		}
		
		return function (url) {
			xmlHttp.open("GET", url, false);
			xmlHttp.send(null);
			return xmlHttp.responseText;
		}
	}
	else if (typeof readFile != "undefined") { // running Rhino?
		return function(path) {
			return readFile(path);
		}
	}
	else {
		throw new Error("Unsupported environment.");
	}
}();

/**
 * @function In rhino-mode, use to save content to a file.
 * @param {string} outDir Path to directory to save into.
 * @param {string} fileName Name to use for the new file.
 * @param {string} content To write to the new file.
 */
SaveFile = function() {
	return function(outDir, fileName, content) {
		var outpath = outDir+FileSeparator+fileName;
		var out = new FileWriter(outpath);
		out.write(content);
		out.flush();
		out.close();
	};
}();

/**
 * @function In rhino-mode, use to copy a file from one directory to another.
 * @param {string} inFile Path to the source file.
 * @param {string} outDir Path to directory to save into.
 * @param {string} fileName Name to use for the new file.
 */
CopyFile = function() {
	return function(inFile, outDir, fileName) {
		if (fileName == null) fileName = JsDoc.Util.fileName(inFile);
		var outpath = outDir+FileSeparator+fileName;
		var out = new FileWriter(outpath);
		out.write(ReadFile(inFile));
		out.flush();
		out.close();
	};
}();

/**
 * @function In rhino-mode, use to create a new directory.
 * @param {string} dirname Path of directory you wish to create.
 */
MakeDir = function() {
	return function(dirName) {
		(new File(dirName)).mkdir();
	};
}();

if (typeof arguments != "undefined") { // running under Rhino?
	var opt = JsDoc.Util.getOptions(arguments, {d:"directory", t:"template", r:"recurse", v:"verbose", h:"help", p:"private", l:"load"});
	JsDoc.main(opt);
}
